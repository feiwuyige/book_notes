[TOC]



# 深入探索C++对象模型

## 第一章 关于对象（Object Lessons）

### 1.1 C++ 对象模式

1. 在 C++ 中，有两种 class member：`static 和 nonstatic`，以及三种 class function：`static, nonstatic, virtual` ；所谓的 C++ 对象模式，就在于编译器如何来存放这些数据，目前 C++ 采用的方式如下：
   * static 数据成员存放在类对象之外， nonstatic 数据成员存放在类对象之内。
   * static 函数和 nonstatic 函数都存放在类对象之外。
   * virtual 函数通过以下方式支持：
     *  每个**类**产生出一堆指向虚函数的函数指针，存放在表格之中，这个表格被称为 virtual table（vtbl）。
     * 每一个**类对象**中添加一个指针，指向相关的 vtbl，这个指针被称为 vptr，vptr 的值由编译器来确定，每一个 class 所关联的 type_info object（用以支持 RTTI）也有 vtbl 来指出，一般位于表格的第一项。
2. C++ 的继承模型中，base class subobject 的 data members 直接放置于 derived class object 中。
3. 虚拟继承的情况下，base class 不管在继承的串链中被派生多少次，永远只会存在一个实体。

### 1.2 关键词所带来的差异

1.  C++ 中的 struct 关键字很大程度上是为了与 C 保持兼容，在 C 里面使用 struct 关键字是为了定义一系列数据的集合，在 C++ 中除了封装数据，也可以封装对于数据的操作，所以 struct 关键字和 class 关键字更多的是逻辑意义上的不同，在 C++ 中，有以下不同：
   * 使用 struct 关键字声明的类默认 access level 是 public，使用 class 关键字声明的类默认 access level 是 private。
   * 因为模板是 C++ 所特有的，所以在 typename 可以和 class 关键字来声明模板参数类型，不支持 struct。
   
2. 由于 `struct` 关键字的语意在 C 与 CPP 中有些许不同，这就导致一些 C 中的技巧在 CPP 中将不再有用，比如：
   ```c
   struct mumble{
       // members
       char pc[1];
   };
   //读取一个 string，然后为 struct 和字符串分配足够的内存
   struct mumble *pmumble = (struct mumble *)malloc(sizeof(struct mumble) + strlen(string) + 1);
   ```

   这里是**柔性数组**的概念，核心目的是在结构体中存放一个只有在运行的时候才能去确定长度的数组。但是在 CPP 中，这种技巧可能不再有用，因为 **CPP 中保证，处于同一个 access level 的数据，必定按照其声明顺序出现在内存布局当中，然而被放置在多个 access level 中的数据，顺序则不一定了。**除此以外，还有以下原因：

   * base object 和 derived object 的布局也没有谁先谁后的强制规定。
   * 虚函数的存在。

### 1.3 对象的差异

1.  CPP 支持三种 programming paradigms:
   * 程序模型，和 C 一样。
   * 抽象数据类型模型，class 定义数据成员和方法。
   * 面向对象模型，定义抽象接口，继承、多态。
2. 只有通过 pointer 和 reference，才能在面向对象模型中实现多态。在 OO 模型中，程序员需要处理一个未知实体，它的类型虽然有所界定，但是由于继承体系，它的实际类型理论上有无限种可能，即被指定的 object 类型在执行点被解析之前，是无法确切知道它的类型的，而对于 ADT 模型中，每个实体在编译时就已经确定好了。
3. CPP 使用下列方式支持多态：
   * 隐含的转换操作，即一个基类类型的指针和引用可以指向派生类类型。
   * 使用虚函数机制，利用虚表来实现多态。
   * 通过 `dynamic_cast` 和 `typeid` 运算符。
4. 不管什么类型的指针，占用的内存大小都是确定的，它的类型只是影响了编译器如何解释某个特定地址中的内存内容及大小。
5. 当我们使用指针进行函数调用的时候，会依据指针的静态类型（声明的类型）在编译期间确定如下两点：
   * 固定的可用接口。即通过某个指针调用函数的时候，这个函数一定要是其静态类型中的接口。
   * 访问级别。通过静态类型中的类的访问接口来判断是否有权进行调用。
6. 指针和引用之所以支持多态，是因为它们并不会引发内存中任何**“与类型有关的内存委托操作”**[^1]，受到影响的仅仅是它们所指向内存的大小和内容解释方式。
7. 假定我们调用p->mem（）（或者obj.mem（）），则依次执行以下4个步骤：
   * 首先确定p（或obj）的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型。
   * 在p（或obj）的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错。
   * 一旦找到了mem，就进行常规的类型检查以确认对于当前找到的mem，本次调用是否合法。
   * 假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码：
     * 如果mem是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。
     * 反之，如果mem不是虚函数或者我们是通过对象（而非引用或指针）进行调用，则编译器将产生一个常规函数调用。



[^1]: 这里指的是编译器在编译阶段为对象分配内存、确定成员偏移量、安排虚表指针位置等操作时，**必须依据一个具体的、已知的类型**来做出决定。编译器必须“承诺”这个对象在内存中严格按照某个特定类型的布局来组织。
