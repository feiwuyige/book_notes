# C++ 之旅

## 第一章 基础

1. C++ 是一门静态类型语言。这意味着每一个实体（例如对象、值、名称和表达式）在使用的那一刻，编译器必须知道其准确的类型。目标的类型决定了目标适用的操作集合以及其在内存中的布局。

2. 函数参数传递的语义与初始化的语义相同，即初始化时候会发生的事情在函数参数传递的时候也会发生。

3. 声明（declaration）是一条语句，为程序引入了一个实体，并且指定它的类型：

   * 类型（type）：定义了对象的取值范围和可进行的操作
   * 对象（object）：某个存放特定类型值的内存控件
   * 值（value）：一系列二进制位，具体含义由其类型定义
   * 变量（variable）：一个有名字的对象

4. 为了提高长字面量的可读性，可以使用单引号（'）分隔数字，例如`3.1415'9265`。

5. 初始化：

   * 使用 `=` 进行初始化。
   * 更通用的是使用花括号括起来并用逗号分隔的初始化列表， `=` 可以省略，该初始化方式可以避免**窄化类型转换**（比如使用赋值初始化时可能将 `double` 隐式转化为 `int` ）。

6. 如果变量的类型可以根据 **初始化符号** 推导出来，就可以使用 `auto` 关键字。

7. 作用域：

   * 局部作用域：在函数或者匿名函数中定义的名字称为**局部名字**，其作用域从声明它的地方开始，到声明语句所在的块结尾为止。
   * 类作用域：如果一个名字被定义在类的内部，并且不在任何函数、匿名函数、enum class 中，那么它可以被称为**成员名字**，作用域从它括起的左花括号 { 开始，到对应的右花括号 } 结束。
   * 命名空间作用域：如果一个名字被定义在命名空间的内部，并且不在任何函数、匿名函数、enum class 中，那么它可以被称为**命名空间成员名字**，作用域从声明它的地方开始，到命名空间结束为止。声明在所有结构之外的名字称为**全局名字**，即位于全局命名空间。

   对象（一段内存）必须被构造才能被使用，并且在退出作用域时被销毁：

   * 命名空间对象：在程序结束时销毁
   * 成员名字：销毁时间取决于所属对象的销毁时间
   * new 创建的对象：用 delete 将其销毁

8. C++支持两种不变性：

   * `const` ：承诺不修改这个值（只读）。const 声明的值 **可以** 在运行期间计算。
   * `constexpr`：在编译期间计算出的值。所以可以将这些数据存放在只读内存区域以提高性能。 constexpr 的值必须由编译器计算出。为了使得一个函数可以在 **常量表达式** 中使用，这个函数必须被定义为 `constexpr` 或 `consteval` 。

   一个 `constexpr` 可以输入非常量参数调用，但是此时返回值不是常量表达式，如果要求某个函数仅在编译时计算，可以声明为 `consteval` 而不是 `constexpr` ：
   ```cpp
   constexpr double square(double x ) {return x * x;}
   constexpr double max1 = 1.4 * square(17); //正确， 17 是常量，返回常量
   constexpr double max2 = 1.4 * square(var); //错误， var 不是常量，所以 square(var) 不是常量
   const double max3 = 1.4 * square(var); //正确， const 允许在运行时计算
   
   consteval double square(double x ) {return x * x;}
   constexpr double max1 = 1.4 * square(17); //正确，是常量表达式
   const double max2 = 1.4 * square(var); //错误， var 不是常量
   ```

   被声明为 `consteval` 和 `constexpr` 的函数是 C++ 版本的 **纯函数**（不能有任何副作用，只能使用输入参数作为信息，尤其不能修改非局部变量，数学上的函数）。