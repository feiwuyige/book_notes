# C++ 之旅

## 第一章 基础

1. C++ 是一门静态类型语言。这意味着每一个实体（例如对象、值、名称和表达式）在使用的那一刻，编译器必须知道其准确的类型。目标的类型决定了目标适用的操作集合以及其在内存中的布局。

2. 函数参数传递的语义与初始化的语义相同，即初始化时候会发生的事情在函数参数传递的时候也会发生。

3. 声明（declaration）是一条语句，为程序引入了一个实体，并且指定它的类型：

   * 类型（type）：定义了对象的取值范围和可进行的操作
   * 对象（object）：某个存放特定类型值的内存控件
   * 值（value）：一系列二进制位，具体含义由其类型定义
   * 变量（variable）：一个有名字的对象

4. 为了提高长字面量的可读性，可以使用单引号（'）分隔数字，例如`3.1415'9265`。

5. 初始化：

   * 使用 `=` 进行初始化。
   * 更通用的是使用花括号括起来并用逗号分隔的初始化列表， `=` 可以省略，该初始化方式可以避免**窄化类型转换**（比如使用赋值初始化时可能将 `double` 隐式转化为 `int` ）。

6. 如果变量的类型可以根据 **初始化符号** 推导出来，就可以使用 `auto` 关键字。

7. 作用域：

   * 局部作用域：在函数或者匿名函数中定义的名字称为**局部名字**，其作用域从声明它的地方开始，到声明语句所在的块结尾为止。
   * 类作用域：如果一个名字被定义在类的内部，并且不在任何函数、匿名函数、enum class 中，那么它可以被称为**成员名字**，作用域从它括起的左花括号 { 开始，到对应的右花括号 } 结束。
   * 命名空间作用域：如果一个名字被定义在命名空间的内部，并且不在任何函数、匿名函数、enum class 中，那么它可以被称为**命名空间成员名字**，作用域从声明它的地方开始，到命名空间结束为止。声明在所有结构之外的名字称为**全局名字**，即位于全局命名空间。

   对象（一段内存）必须被构造才能被使用，并且在退出作用域时被销毁：

   * 命名空间对象：在程序结束时销毁
   * 成员名字：销毁时间取决于所属对象的销毁时间
   * new 创建的对象：用 delete 将其销毁

8. C++支持两种不变性：

   * `const` ：承诺不修改这个值（只读）。const 声明的值 **可以** 在运行期间计算。
   * `constexpr`：在编译期间计算出的值。所以可以将这些数据存放在只读内存区域以提高性能。 constexpr 的值必须由编译器计算出。为了使得一个函数可以在 **常量表达式** 中使用，这个函数必须被定义为 `constexpr` 或 `consteval` 。

   但是一个声明为 `constexpr` 的函数也可以输入非常量参数进行调用，此时返回值不再是常量表达式，这样就不需要为了仅仅区分常量表达式与变量输入来定义同样的函数两次。如果要求某个函数仅在编译时计算，则可以声明为 `consteval` 而不是 `constexpr` ：
   ```cpp
   constexpr double square(double x ) {return x * x;}
   constexpr double max1 = 1.4 * square(17); //正确， 17 是常量，返回常量
   constexpr double max2 = 1.4 * square(var); //错误， var 不是常量，所以 square(var) 不是常量
   const double max3 = 1.4 * square(var); //正确， const 允许在运行时计算
   
   consteval double square1(double x ) {return x * x;}
   constexpr double max1 = 1.4 * square1(17); //正确，是常量表达式
   const double max2 = 1.4 * square1(var); //错误，var 不是常量，无法在编译期间运算
   ```

   被声明为 `consteval` 和 `constexpr` 的函数是 C++ 版本的 **纯函数**（不能有任何副作用，只能使用输入参数作为信息，尤其不能修改非局部变量，数学上的函数）。

   总结一下：`const` 关键字修饰的变量可以在运行期间进行赋值，但是 `constexpr` 关键字修饰的变量必须在编译期间求值，修饰的函数依据传入的参数类型来决定返回值是否是常量表达式。`consteval` 关键字只能用来修饰函数，它保证这个函数在编译时计算。

   **常量必须进行初始化！！！**
   
   

## 第二章 用户自定义类型

1. 用基本类型、 `const` 修饰符和声明操作符（& * []）构造出来的类型称为 **内置类型**。

2. 构造函数在初始化类的对象时一定会被调用，因此定义一个构造函数可以消除类变量未初始化造成的问题。

3. `enum class` 中的枚举值作用域在他们的 `enum class` 中，其中的 `class` 表示这个枚举类型是强类型，并且具备独立作用域，同时禁止隐式的转换，如果不想显示指定枚举的名称，并希望枚举值的类型直接是 `int` ，则可以使用 `enum` 。

   ```cpp
   enum class Color{red, blue, green};
   enum class Traffic_light{red, blue, green};
   Color x1 = red; //错误，哪个red?
   Color x2 = Traffic_light::red; //错误，不是color 类型
   Color x3 = Color::red; //true
   int x4 = Color::red; //false，禁止转换
   int x5 = int(Color::red); //正确，允许显式转换
   ```

4. 当重载递增、递减运算符的时候，由于名字相同，所以为了区分是前置版本还是后置版本，后置版本接受一个额外的（不被使用）int类型的形参。

5. 使用标准库中的 `variant` 来代替 `union` 。



## 第三章 模块化

1. 将每个部分的接口和实现分离开来，C++通过声明来表示接口。**声明**指定了使用一个函数或一个类型所需要的所有东西。一个实体可以有很多声明，但是只能有一个定义。

2. C++支持分离编译，用户代码只能看见所用类型和接口。

   * 头文件：将声明放进独立的文件，然后使用 `#include` 去引用它。

   * 模块：定义 `module` 文件，独立的编译它们，然后再需要的时候 `import` 对应的 `module` ，只有显式 `export` 的声明是可见的。
     ```cpp
     //Vector.cpp
     export module Vector;
     export class Vector{
         //....
     };
     export bool operator==(const Vector& v1, const Vector& v2){
     
     }
     //user.cpp
     import Vector;
     ```

     编译器负责把（用 `export` 指定的）模块的接口从实现细节中分离出来，不需要用户指定。

     一个可以单独编译的 `.cpp` (包括 `.h` )文件被称作一个翻译单元。

     * 模块只被编译一次，不会在灭个用到它的翻译单元那里都被重新编译。
     * 两个模块 `import` 的顺序不会影响其含义
     * 如果你在模块中 `import` 或者 `#include` 其他内容，模块的使用者不会隐式的获得这些模块的访问权，即模块没有传染性。

3. 函数参数传递过程中要思考：

   * 对象（内存）是被复制的还是被共享
   * 这个共享对象是否可被修改
   * 这个对象是否被移动，从而留下了一个空对象

   参数传递与返回值的默认行为是复制，但是很多情况下，编译器会将复制优化为移动。

4. 结构化绑定：把类对象的名称赋予局部变量名称的机制叫做结构化绑定。
   ```cpp
   struct Entry{
       string name;
       int value;
   };
   Entry read_entry(){
       
   };
   auto [n, v] = read_entry(); //结构化绑定，类型来自于read_entry()返回类型的推导
   ```




## 第四章 错误处理

1. 约束条件：对一个类来说必定为真的语句。约束条件的概念强调了在 C++ 中的资源管理，而资源管理由构造函数与析构函数支持。
2. 前提条件：在函数中扮演类似于约束条件在类中的类似角色。
3. 如果一个函数不应当抛出异常，那么可以将它声明为 `noexcept` ，该关键字保证，如果在该函数中抛出异常，那么会直接调用 `std::terminate` 中止程序。
4. 错误处理方式：
   * 抛出异常（try catch)
   * 返回错误码
   * 中止程序



## 第五章 类

1. * 具体类：它们的行为像内置类型一样。
   * 抽象类：将使用者与类的实现细节完全隔离开（纯虚函数）。作为接口出现，它的派生类负责具体实现。我们不能纯定义一个抽象类对象，因为我们对抽象类的实现一无所知（甚至大小都不了解，所以编译器无法在栈上分配空间，也就是在运行时分配空间，因为编译期间无法确定），所以必须从自由存储为对象分配空间，然后通过引用和指针来访问对象。
   * 类层次结构：表示具有继承层次结构的一组概念。
2. 容器：包含若干元素的对象（内存空间）。
3. RAII(资源获取即初始化)：在构造函数中获取资源，然后在析构函数中释放它们。
4. 每个含有虚函数的类都有它自己的虚函数表（vtbl），编译器将虚函数的名字转化为函数指针表中对应的索引值。该类的对象都需要一个额外的指针指向虚函数表。
5. 要将基类中的析构函数声明为虚函数。这样当使用一个基类指针释放派生类对象时，虚函数调用机制就能保证我们调用正确的析构函数，然后该析构函数 再隐式调用其基类的析构函数和成员的析构函数。
6. 在运行时如果 `dynamic_cast` 的参数所指对象的类型与期望的类型或者期望类型的派生类不符，则返回的结果是 `nullptr` 。



## 第六章 基本操作

1. 对象被移动或者拷贝的情况：

   * 赋值给其他对象
   * 作为对象初始值
   * 作为函数的实参
   * 作为函数的返回值
   * 作为异常

   赋值语句使用拷贝或者移动赋值操作符，其他情况下将使用移动构造函数或拷贝构造函数。而且拷贝与移动构造函数常常被优化为在目标对象的位置直接初始化。

2. 接受单个参数的构造函数同时也定义了从参数类型到类类型的转换。`explicit` 关键字。

3. 当一个类被作为**资源句柄**时，也就是这个类负责通过指针访问一个对象时，采用默认的逐成员复制方式通常是错误的。这是因为类的对象将指向同一个资源，一个修改也会影响到另一个，但是用户往往不是为了这个目的，正确做法应该是复制一份资源，让新的对象指向这个新复制得到的资源。

4. 右值引用：可理解为引用了一个别人无法为其赋值的内容，所以可以安全的“窃取”它的值，也就是可以进行移动。

5. 使用移动构造函数或者智能指针把资源从一个作用域移动到另一个作用域，使用共享指针分享资源的所有权。

6. `<=>` ：该操作符与 C 语言中的 `strcmp()` 一样，返回负数表示小于，返回零表示等于，返回正数表示大于。在定义了默认的 `<=>` 操作符，其他关系操作符会被隐式定义。当 `<=>` 没被声明为 default 时，不会隐式定义 `==` 操作符，但是 `<` 符号以及其他操作符会被定义。

7. 可以通过给字面量加后缀生成用户定义字面量， `"hello,world"s` 是 `std::string` 类型的。



## 第七章 模板

1. 受限模板参数：
   ```cpp
   template <Element T>
   class Vector{
   private:
       T* elem;
       int size;
   };
   ```

   `template<Element T> ` 前缀是 C++ 对数学中 “对所有 T 满足Elemment(T)” 的描述。即 `Element` 是一个谓词，用于检查 `T` 是否满足 `Vector` 需要的特性，这种谓词叫做 **概念**，在模板参数中指定一个概念，这叫做 **受限模板参数**，拥有这种参数的模板叫做**受限模板**。

2. 由于隐晦的技术原因，字符串字面量不可以作为**模板值参数**。

3. C 风格的字符串字面量类型是 `const char*`。

4. 如果初始化列表中的元素有不同的类型，编译器就无法推导出唯一的元素类型。

5. 推导指引：
   ```cpp
   template <tyname Iter>
   	Vector(Iter, Iter) -> Vector<typename Iter::value_type>;
   ```

6. 要想表达将操作用类型或者值来参数化，有三种方法：

   * 模板函数
   * 函数对象：对象可以携带数据，并且以函数的形式调用(重载调用运算符)
   * 匿名函数表达式：函数对象的简略记法

7. 模板函数不能是虚函数，因为编译器无法知道模板的所有实例，不可能为模板函数生成 `vtbl` 。

8. 谓词：可以调用并返回 `true` 或 `false` 的对象。

9. [[ nodiscard]] 属性表示函数的返回值不应该被忽略，如果忽略编译器就会发生警告。

10. 作用域终结函数：
    ```cpp
    void old_style(int n){
    	void *p = malloc(n * sizeof(int));
        //必须手动free，为了实现RAII思想，我们可以如下做
        auto act = finally([&]{free p;});
        //act 是一个对象，他会在函数执行完毕以后执行析构函数
    }
    //finally()实现，即返回一个具体的对象
    template <class F>
        [[nodiscard]] auto finally(F f){
    	return Final_action{f};
    }
    //Final_action类
    template <class F>
        struct Final_action{
    		explicit Final_action(F f) : act(f) {}
            ~Final_action() {act();}
            F act;
        };
    ```

11. 模板机制：

    * 依赖类型的值：参数模板
      ```cpp
      //定义一个模板类的时候往往需要定义对应类型的常量和值
      template <class T>
      	constexpr T viscosity = 0.4;
      template <typename T, typename T2>
      constexpr bool Assignable = is_assignable<T&, T2>::value;
      ```

    * 类型与模板的别名：别名模板
      ```cpp
      template <typename C>
      	using Value_type = C::value_type; //C的元素类型
      template <typename Container>
      void algo(Container& c){
      	Vector<Value_type<Container> > vec; //根据 Value_type这个别名模板读出对应类型
      }
      ```

    * 编译时选择机制： if constexpr(c++ 17)
      ```CPP
      //if constexpr 允许在编译时对类型、常量值等进行判断，并根据条件决定是否编译某一部分代码。
      if constexpr (条件) {
          // 条件为真时编译此部分代码
      } else {
          // 条件为假时编译此部分代码
      }
      ```

    * 编译时查询值与表达式属性的机制：requires 表达式(见第八章)

## 第八章 概念和泛型编程

1. 概念：比如在一个函数模板中，我们对于实例化的参数有一定的要求，这种要求叫做 **概念（concept）**。
2. 在使用模板的时候，`typename` 可以理解为最低的类型要求，只需要是一个类型即可，我们可以定义相关的概念，然后用这个关键字来替代 `typename`，比如一个求和函数，我们要求第一个参数是一个序列，第二个参数是一个数字，同时要满足序列中的元素可以与第二个参数进行运算，即可定义如下：
   ```cpp
   template <Sequence Seq, Number Num>
   	requires Arithmetic<range_value_t<Seq>, Num>
   Num Sum(Seq s, Num n);
   //也可以如下定义
   template <typename Seq, typename Num>
   	requires Sequence<Seq> && Number<Num> && Arithmetic<range_value_t<Seq>, Num>
   Num Sum(Seq s, Num n);
   ```

3. 可以基于概念对函数进行重载，即函数名称相同，但是概念不同，则编译器在调用的时候会选择符合概念的函数。

4. 定义概念：
   ```cpp
   template <forward_iterator Iter>
   	requires requires (Iter p, int i){p[i]; p+i;}
   void advance(Iter p, int n){
       p += n;
   }
   ```

   第一个 `requires` 表示开始一个 `requiresment` 字句；第二个 `requires` 表示开始一个 `requires` 表达式，这是一个谓词，代码有效则返回 `true`，否则返回 `false` 。个人理解是在语句中直接定义概念

   ```cpp
   template <typename T>
   concept Equality_comparable = 
   	requires (T a, T b){
       {a == b} -> Boolean; //Boolean也是一个概念
       {a != b} -> Boolean;
   }
   ```

   概念是一个编译时谓词，指示了一个或多个类型如何被使用。`concept` 的值一定是 `bool` 类型的，此处 `{...}` 的返回值在 `->` 指定，他必须是一个概念。**模板中的概念是用来检查模板实例化时的参数的，并不用于在定义模板时进行检查。**

5. `auto` 关键字表示一个对象与其初始化描述符的类型相同。所以在一个函数中将参数声明为 `auto` 类型，则表示了值得最小约束概念，也就是说他需要的仅仅是某个类型的值，这会将一个函数变成模板函数，我们可以使用概念替换 `auto` ，增强类似初始化需求约束：

   ```cpp
   //仅用于算数类型
   auto twice(Arithmetic auto x){
       return x + x;
   }
   ```

6. **可变参数模板**：定义模板时令其接受任意数量、任意类型的实参，这样的模板称为*可变参数模板*（Variadic template）。我们可以定义模板形参包和函数形参包：

   * 模板形参包：接受零个或更多个模板实参（非类型、类型或模板）的模板形参。
   * 函数形参包：接受零个或更多个函数实参的函数形参。

   ```cpp
   //Args 是模板形参包
   //args 是函数形参包
   template <typename... Args>
   void sum(Args... args){
       
   }
   ```

   形参包的使用：
   后随省略号且其中至少有一个形参包的名字的模式会被*展开* ﻿成零个或更多个逗号分隔的模式实例，其中形参包的名字按顺序被替换成包中的各个元素。

   ```cpp
   template<class... Us>
   void f(Us... pargs) {}
    
   template<class... Ts>
   void g(Ts... args)
   {
       f(&args...); // “&args...” 是包展开
                    // “&args” 是它的模式
   }
    
   g(1, 0.2, "a"); // Ts... args 会展开成 int E1, double E2, const char* E3
                   // &args... 会展开成 &E1, &E2, &E3
                   // Us... 会展开成 int* E1, double* E2, const char** E3
   ```

7. 折叠表达式：使用 `...` ，***折叠表达式是左折叠还是右折叠，取决于 `...` 是在“形参包”的左边还是右边。***
   ```cpp
   template <Number... T>
   int sum(T... v){
   	return (v + ... + 0); //将v中所有元素与0累加，右折叠
       return (0 + ... + v); //左折叠
   }
   ```

   右折叠：最右边的参数先计算，相当于 (v[0] + (v[1] + (v[2] + (v[3] + (v[4] + 0)))));

   左折叠：最左边的参数先计算，相当于(((((0 + v[0]) + v[1]) + v[2]) + v[3]) + v[4]);

   ```cpp
   template <Printable ...T>
   void print(T&&... args){
   	(std::cout << ... << args) << '\n';
   }
   print("Hello"s, ' ', "World ", 2017);
   //左折叠
   //相当于：(((((std::cout << "Hello"s) << ' ') <<"World") << 2017) << '\n');
   ```

## 第九章 标准库



