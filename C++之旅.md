# C++ 之旅

## 第一章 基础

1. C++ 是一门静态类型语言。这意味着每一个实体（例如对象、值、名称和表达式）在使用的那一刻，编译器必须知道其准确的类型。目标的类型决定了目标适用的操作集合以及其在内存中的布局。

2. 函数参数传递的语义与初始化的语义相同，即初始化时候会发生的事情在函数参数传递的时候也会发生。

3. 声明（declaration）是一条语句，为程序引入了一个实体，并且指定它的类型：

   * 类型（type）：定义了对象的取值范围和可进行的操作
   * 对象（object）：某个存放特定类型值的内存控件
   * 值（value）：一系列二进制位，具体含义由其类型定义
   * 变量（variable）：一个有名字的对象

4. 为了提高长字面量的可读性，可以使用单引号（'）分隔数字，例如`3.1415'9265`。

5. 初始化：

   * 使用 `=` 进行初始化。
   * 更通用的是使用花括号括起来并用逗号分隔的初始化列表， `=` 可以省略，该初始化方式可以避免**窄化类型转换**（比如使用赋值初始化时可能将 `double` 隐式转化为 `int` ）。

6. 如果变量的类型可以根据 **初始化符号** 推导出来，就可以使用 `auto` 关键字。

7. 作用域：

   * 局部作用域：在函数或者匿名函数中定义的名字称为**局部名字**，其作用域从声明它的地方开始，到声明语句所在的块结尾为止。
   * 类作用域：如果一个名字被定义在类的内部，并且不在任何函数、匿名函数、enum class 中，那么它可以被称为**成员名字**，作用域从它括起的左花括号 { 开始，到对应的右花括号 } 结束。
   * 命名空间作用域：如果一个名字被定义在命名空间的内部，并且不在任何函数、匿名函数、enum class 中，那么它可以被称为**命名空间成员名字**，作用域从声明它的地方开始，到命名空间结束为止。声明在所有结构之外的名字称为**全局名字**，即位于全局命名空间。

   对象（一段内存）必须被构造才能被使用，并且在退出作用域时被销毁：

   * 命名空间对象：在程序结束时销毁
   * 成员名字：销毁时间取决于所属对象的销毁时间
   * new 创建的对象：用 delete 将其销毁

8. C++支持两种不变性：

   * `const` ：承诺不修改这个值（只读）。const 声明的值 **可以** 在运行期间计算。
   * `constexpr`：在编译期间计算出的值。所以可以将这些数据存放在只读内存区域以提高性能。 constexpr 的值必须由编译器计算出。为了使得一个函数可以在 **常量表达式** 中使用，这个函数必须被定义为 `constexpr` 或 `consteval` 。

   但是一个声明为 `constexpr` 的函数也可以输入非常量参数进行调用，此时返回值不再是常量表达式，这样就不需要为了仅仅区分常量表达式与变量输入来定义同样的函数两次。如果要求某个函数仅在编译时计算，则可以声明为 `consteval` 而不是 `constexpr` ：
   ```cpp
   constexpr double square(double x ) {return x * x;}
   constexpr double max1 = 1.4 * square(17); //正确， 17 是常量，返回常量
   constexpr double max2 = 1.4 * square(var); //错误， var 不是常量，所以 square(var) 不是常量
   const double max3 = 1.4 * square(var); //正确， const 允许在运行时计算
   
   consteval double square1(double x ) {return x * x;}
   constexpr double max1 = 1.4 * square1(17); //正确，是常量表达式
   const double max2 = 1.4 * square1(var); //错误，var 不是常量，无法在编译期间运算
   ```

   被声明为 `consteval` 和 `constexpr` 的函数是 C++ 版本的 **纯函数**（不能有任何副作用，只能使用输入参数作为信息，尤其不能修改非局部变量，数学上的函数）。

   总结一下：`const` 关键字修饰的变量可以在运行期间进行赋值，但是 `constexpr` 关键字修饰的变量必须在编译期间求值，修饰的函数依据传入的参数类型来决定返回值是否是常量表达式。`consteval` 关键字只能用来修饰函数，它保证这个函数在编译时计算。

   **常量必须进行初始化！！！**
   
   

## 第二章 用户自定义类型

1. 用基本类型、 `const` 修饰符和声明操作符（& * []）构造出来的类型称为 **内置类型**。

2. 构造函数在初始化类的对象时一定会被调用，因此定义一个构造函数可以消除类变量未初始化造成的问题。

3. `enum class` 中的枚举值作用域在他们的 `enum class` 中，其中的 `class` 表示这个枚举类型是强类型，并且具备独立作用域，同时禁止隐式的转换，如果不想显示指定枚举的名称，并希望枚举值的类型直接是 `int` ，则可以使用 `enum` 。

   ```cpp
   enum class Color{red, blue, green};
   enum class Traffic_light{red, blue, green};
   Color x1 = red; //错误，哪个red?
   Color x2 = Traffic_light::red; //错误，不是color 类型
   Color x3 = Color::red; //true
   int x4 = Color::red; //false，禁止转换
   int x5 = int(Color::red); //正确，允许显式转换
   ```

4. 当重载递增、递减运算符的时候，由于名字相同，所以为了区分是前置版本还是后置版本，后置版本接受一个额外的（不被使用）int类型的形参。

5. 使用标准库中的 `variant` 来代替 `union` 。



## 第三章 模块化

1. 将每个部分的接口和实现分离开来，C++通过声明来表示接口。**声明**指定了使用一个函数或一个类型所需要的所有东西。一个实体可以有很多声明，但是只能有一个定义。

2. C++支持分离编译，用户代码只能看见所用类型和接口。

   * 头文件：将声明放进独立的文件，然后使用 `#include` 去引用它。

   * 模块：定义 `module` 文件，独立的编译它们，然后再需要的时候 `import` 对应的 `module` ，只有显式 `export` 的声明是可见的。
     ```cpp
     //Vector.cpp
     export module Vector;
     export class Vector{
         //....
     };
     export bool operator==(const Vector& v1, const Vector& v2){
     
     }
     //user.cpp
     import Vector;
     ```

     编译器负责把（用 `export` 指定的）模块的接口从实现细节中分离出来，不需要用户指定。

     一个可以单独编译的 `.cpp` (包括 `.h` )文件被称作一个翻译单元。

     * 模块只被编译一次，不会在灭个用到它的翻译单元那里都被重新编译。
     * 两个模块 `import` 的顺序不会影响其含义
     * 如果你在模块中 `import` 或者 `#include` 其他内容，模块的使用者不会隐式的获得这些模块的访问权，即模块没有传染性。

3. 函数参数传递过程中要思考：

   * 对象（内存）是被复制的还是被共享
   * 这个共享对象是否可被修改
   * 这个对象是否被移动，从而留下了一个空对象

   参数传递与返回值的默认行为是复制，但是很多情况下，编译器会将复制优化为移动。

4. 结构化绑定：把类对象的名称赋予局部变量名称的机制叫做结构化绑定。
   ```cpp
   struct Entry{
       string name;
       int value;
   };
   Entry read_entry(){
       
   };
   auto [n, v] = read_entry(); //结构化绑定，类型来自于read_entry()返回类型的推导
   ```




## 第四章 错误处理

1. 约束条件：对一个类来说必定为真的语句。约束条件的概念强调了在 C++ 中的资源管理，而资源管理由构造函数与析构函数支持。
2. 前提条件：在函数中扮演类似于约束条件在类中的类似角色。
3. 如果一个函数不应当抛出异常，那么可以将它声明为 `noexcept` ，该关键字保证，如果在该函数中抛出异常，那么会直接调用 `std::terminate` 中止程序。
4. 错误处理方式：
   * 抛出异常（try catch)
   * 返回错误码
   * 中止程序



## 第五章 类

1. * 具体类：它们的行为像内置类型一样。
   * 抽象类：将使用者与类的实现细节完全隔离开（纯虚函数）。作为接口出现，它的派生类负责具体实现。我们不能纯定义一个抽象类对象，因为我们对抽象类的实现一无所知（甚至大小都不了解，所以编译器无法在栈上分配空间，也就是在运行时分配空间，因为编译期间无法确定），所以必须从自由存储为对象分配空间，然后通过引用和指针来访问对象。
   * 类层次结构：表示具有继承层次结构的一组概念。
2. 容器：包含若干元素的对象（内存空间）。
3. RAII(资源获取即初始化)：在构造函数中获取资源，然后在析构函数中释放它们。
4. 每个含有虚函数的类都有它自己的虚函数表（vtbl），编译器将虚函数的名字转化为函数指针表中对应的索引值。该类的对象都需要一个额外的指针指向虚函数表。
5. 要将基类中的析构函数声明为虚函数。这样当使用一个基类指针释放派生类对象时，虚函数调用机制就能保证我们调用正确的析构函数，然后该析构函数 再隐式调用其基类的析构函数和成员的析构函数。
6. 在运行时如果 `dynamic_cast` 的参数所指对象的类型与期望的类型或者期望类型的派生类不符，则返回的结果是 `nullptr` 。



## 第六章 基本操作

