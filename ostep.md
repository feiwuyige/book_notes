[TOC]

# OSTEP

## 第一部分 虚拟化

### 第四章 抽象：进程

1. 理解进程的关键在于理解它的**机器状态（state machine）**，即程序在运行时可以读取或更新的内容。
   * 内存：程序的指令是存放在内存中的，进程读取和写入的数据也在内存中。进程可以访问的内存称为**地址空间（address space）。**
   * 寄存器：PC指针，栈基址 rbp，栈顶指针 rsp
   * 磁盘：程序可能会修改磁盘中的内容，比如当前程序打开的文件。
2. 进程api：操作系统是对硬件的抽象，同时在应用视角应该是给应用程序提供服务，也就是 api，所以显然操作系统中应该有一组处理进程的 api：
   * 创建进程(create)：创建一个新的进程。
   * 销毁进程(destroy)：如果进程不能正常退出，应当可以关闭。
   * 等待进程(wait)：有的时候进程之间需要同步，所以可能需要某一个进程等待另一个进程完成。
   * 其他控制(miscellanous control)：比如可能将某个进程暂时挂起，然后再恢复。
   * 状态(statu)：获取当前进程的相关信息，比如占用了多少内存。
3. 进程创建的步骤：
   * 程序的指令和数据只有在内存中才可以执行，而程序就是一个存放在磁盘上的文件，所以**首先一定要先将程序从磁盘加载到内存中**。
   * 为程序的运行时栈分配内存。
   * 为程序的堆分配一些内存。
   * 其他初始化任务，比如打开进程的文件描述符，将0 1 2绑定到标准输入、标准输出、标准错误输出。
   * 启动程序，将 CPU 的控制权转移到新创建的进程中去。
4. 进程的状态：
   * 运行：正在占用 CPU
   * 就绪：等待调度，可以去 CPU 上执行指令
   * 阻塞：因为某些原因需要等待某些操作完成，比如 I / O，此时不需要 CPU ，所以让 CPU 调度其他程序，从而提高效率。

### 第五章 插叙：进程API



## 第 26 章 并发：介绍

1. 线程：为当个运行进程提供的抽象。经典观点是一个程序只有一个执行点（一个ip寄存器，用来存放要执行的指令地址），但是多线程程序会有多个执行点（多个pc，每个都用于取指令和执行）。换一个角度看，每一个线程类似于独立的进程，只有一点区别：**线程之间共享地址空间，从而可以访问相同的数据。**每个线程有自己的一组用于计算的寄存器，所以在一个处理器上切换线程，就必须要保存相关信息。对于进程，我们将状态保存到进程控制块（PCB），而对于线程，我们需要一个或多个线程控制块（TCB）。但是，与进程相比，线程之间的上下文切换有一点主要区别：**地址空间保持不变（即不需要切换当前使用的页表）**，进程与线程之间的另一个主要区别在于栈，多线程程序中每一个线程都有一个栈。
2. 

